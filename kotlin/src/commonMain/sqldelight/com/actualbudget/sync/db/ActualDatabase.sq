-- Accounts table (simplified to match Actual Budget's actual schema)
CREATE TABLE accounts (
    id TEXT PRIMARY KEY NOT NULL,
    name TEXT,
    offbudget INTEGER DEFAULT 0,
    closed INTEGER DEFAULT 0,
    tombstone INTEGER DEFAULT 0,
    sort_order REAL
);

-- Payees table (minimal columns that exist in all Actual versions)
CREATE TABLE payees (
    id TEXT PRIMARY KEY NOT NULL,
    name TEXT,
    category TEXT,
    tombstone INTEGER DEFAULT 0,
    transfer_acct TEXT  -- Account ID if this is a transfer payee
);

-- Payee mapping rules (NOTE: No tombstone column - matches Actual Budget schema)
CREATE TABLE payee_mapping (
    id TEXT PRIMARY KEY NOT NULL,
    targetId TEXT
);

-- Category groups (matches Actual Budget schema)
CREATE TABLE category_groups (
    id TEXT PRIMARY KEY NOT NULL,
    name TEXT,
    is_income INTEGER DEFAULT 0,
    sort_order REAL,
    tombstone INTEGER DEFAULT 0,
    hidden INTEGER DEFAULT 0
);

-- Categories (matches Actual Budget schema)
CREATE TABLE categories (
    id TEXT PRIMARY KEY NOT NULL,
    name TEXT,
    is_income INTEGER DEFAULT 0,
    cat_group TEXT,
    sort_order REAL,
    tombstone INTEGER DEFAULT 0,
    hidden INTEGER DEFAULT 0
);

-- Transactions (minimal columns that exist in all Actual versions)
-- Note: 'description' column stores the payee ID (not the payee name)
-- Split transactions: isParent=1 for parent, isChild=1 with parent_id for children
-- Transfer transactions: transferred_id links to paired transaction in other account
CREATE TABLE transactions (
    id TEXT PRIMARY KEY NOT NULL,
    acct TEXT,
    category TEXT,
    amount INTEGER,
    description TEXT,
    notes TEXT,
    date INTEGER,
    sort_order REAL,
    tombstone INTEGER DEFAULT 0,
    cleared INTEGER DEFAULT 1,
    pending INTEGER DEFAULT 0,
    reconciled INTEGER DEFAULT 0,
    isParent INTEGER DEFAULT 0,
    isChild INTEGER DEFAULT 0,
    parent_id TEXT,
    transferred_id TEXT  -- Links to paired transfer transaction
);

-- Monthly budget amounts
CREATE TABLE zero_budgets (
    id TEXT PRIMARY KEY NOT NULL,
    month INTEGER NOT NULL,
    category TEXT NOT NULL,
    amount INTEGER NOT NULL DEFAULT 0,
    carryover INTEGER NOT NULL DEFAULT 0,
    goal INTEGER,
    tombstone INTEGER NOT NULL DEFAULT 0
);

-- Notes (for accounts, categories, etc.)
CREATE TABLE notes (
    id TEXT PRIMARY KEY NOT NULL,
    note TEXT NOT NULL DEFAULT ''
);

-- Budget months table for hold operations (buffered amounts for zero-based budgeting)
CREATE TABLE zero_budget_months (
    id TEXT PRIMARY KEY NOT NULL,  -- month in "YYYYMM" format
    buffered INTEGER NOT NULL DEFAULT 0
);

-- Schedules for recurring transactions
CREATE TABLE schedules (
    id TEXT PRIMARY KEY NOT NULL,
    rule TEXT,
    active INTEGER NOT NULL DEFAULT 1,
    completed INTEGER NOT NULL DEFAULT 0,
    posts_transaction INTEGER NOT NULL DEFAULT 0,
    tombstone INTEGER NOT NULL DEFAULT 0,
    name TEXT
);

-- Schedule-transaction link
CREATE TABLE schedule_next_date (
    id TEXT PRIMARY KEY NOT NULL,
    schedule_id TEXT NOT NULL,
    local_next_date INTEGER,
    local_next_date_ts INTEGER,
    base_next_date INTEGER,
    base_next_date_ts INTEGER,
    tombstone INTEGER NOT NULL DEFAULT 0
);

-- Rules for auto-categorization
CREATE TABLE rules (
    id TEXT PRIMARY KEY NOT NULL,
    stage TEXT,
    conditions TEXT,
    actions TEXT,
    tombstone INTEGER NOT NULL DEFAULT 0
);

-- CRDT messages log (for sync) - matches Actual Budget's schema
-- Note: value is TEXT not BLOB because web app stores serialized strings (e.g., "S:value")
-- and sql.js returns BLOB as Uint8Array which breaks protobuf serialization
CREATE TABLE messages_crdt (
    id INTEGER PRIMARY KEY,
    timestamp TEXT NOT NULL UNIQUE,
    dataset TEXT NOT NULL,
    row TEXT NOT NULL,
    column TEXT NOT NULL,
    value TEXT NOT NULL
);

CREATE INDEX messages_crdt_search ON messages_crdt(dataset, row, column, timestamp);

-- Performance indexes for common query patterns
CREATE INDEX IF NOT EXISTS idx_transactions_acct ON transactions(acct);
CREATE INDEX IF NOT EXISTS idx_transactions_date ON transactions(date);
CREATE INDEX IF NOT EXISTS idx_transactions_parent_id ON transactions(parent_id);
CREATE INDEX IF NOT EXISTS idx_zero_budgets_month ON zero_budgets(month);

-- Sync metadata
CREATE TABLE sync_metadata (
    key TEXT PRIMARY KEY NOT NULL,
    value TEXT
);

-- ============= QUERIES =============

-- Accounts
getAccounts:
SELECT * FROM accounts WHERE tombstone = 0 ORDER BY sort_order;

getAccountById:
SELECT * FROM accounts WHERE id = ?;

insertAccount:
INSERT OR REPLACE INTO accounts(id, name, offbudget, closed, sort_order, tombstone)
VALUES (?, ?, ?, ?, ?, ?);

-- Payees
getPayees:
SELECT * FROM payees WHERE tombstone = 0 ORDER BY name;

getPayeeById:
SELECT * FROM payees WHERE id = ?;

insertPayee:
INSERT OR REPLACE INTO payees(id, name, category, tombstone, transfer_acct)
VALUES (?, ?, ?, ?, ?);

-- Payee Mapping
getPayeeMappingById:
SELECT * FROM payee_mapping WHERE id = ?;

insertPayeeMapping:
INSERT OR REPLACE INTO payee_mapping(id, targetId)
VALUES (?, ?);

-- Category Groups
getCategoryGroups:
SELECT * FROM category_groups WHERE tombstone = 0 ORDER BY sort_order;

getCategoryGroupById:
SELECT * FROM category_groups WHERE id = ?;

insertCategoryGroup:
INSERT OR REPLACE INTO category_groups(id, name, is_income, sort_order, hidden, tombstone)
VALUES (?, ?, ?, ?, ?, ?);

-- Categories
getCategories:
SELECT * FROM categories WHERE tombstone = 0 ORDER BY sort_order;

getCategoriesByGroup:
SELECT * FROM categories WHERE cat_group = ? AND tombstone = 0 ORDER BY sort_order;

getCategoryById:
SELECT * FROM categories WHERE id = ?;

insertCategory:
INSERT OR REPLACE INTO categories(id, name, cat_group, is_income, sort_order, hidden, tombstone)
VALUES (?, ?, ?, ?, ?, ?, ?);

-- Transactions
-- Note: isParent = 0 filters out parent transactions to avoid double-counting splits
getTransactionsByAccount:
SELECT * FROM transactions WHERE acct = ? AND tombstone = 0 AND isParent = 0 ORDER BY date DESC, sort_order DESC;

-- All transactions for display including parents (for accordion grouping in UI)
-- Use this for display, then group parents with their children in Swift
-- Sort puts parents before their children (parent_id NULL first for parents)
-- For transfer payees (transfer_acct set), resolves to account name instead of empty payee name
getTransactionsForDisplayByAccount:
SELECT
    t.id,
    t.acct,
    t.category,
    t.amount,
    t.description,
    t.notes,
    t.date,
    t.sort_order,
    t.cleared,
    t.pending,
    t.reconciled,
    t.isParent,
    t.isChild,
    t.parent_id,
    COALESCE(transfer_acct.name, p.name) AS payee_name,
    c.name AS category_name
FROM transactions t
LEFT JOIN payees p ON t.description = p.id
LEFT JOIN accounts transfer_acct ON p.transfer_acct = transfer_acct.id
LEFT JOIN categories c ON t.category = c.id
WHERE t.acct = ? AND t.tombstone = 0
ORDER BY t.date DESC, t.sort_order DESC, t.isParent DESC;

-- Transactions with payee and category names pre-joined (optimized for list views)
-- Eliminates N dictionary lookups in the UI layer
-- Note: isParent = 0 filters out parent transactions to avoid double-counting splits
-- For transfer payees (transfer_acct set), resolves to account name instead of empty payee name
getTransactionsWithDetailsForAccount:
SELECT
    t.id,
    t.acct,
    t.category,
    t.amount,
    t.description,
    t.notes,
    t.date,
    t.sort_order,
    t.cleared,
    t.pending,
    t.reconciled,
    t.isParent,
    t.isChild,
    t.parent_id,
    COALESCE(transfer_acct.name, p.name) AS payee_name,
    c.name AS category_name
FROM transactions t
LEFT JOIN payees p ON t.description = p.id
LEFT JOIN accounts transfer_acct ON p.transfer_acct = transfer_acct.id
LEFT JOIN categories c ON t.category = c.id
WHERE t.acct = ? AND t.tombstone = 0 AND t.isParent = 0
ORDER BY t.date DESC, t.sort_order DESC;

-- Paginated version with LIMIT and OFFSET for large accounts
-- Note: isParent = 0 filters out parent transactions to avoid double-counting splits
-- For transfer payees (transfer_acct set), resolves to account name instead of empty payee name
getTransactionsWithDetailsPaginated:
SELECT
    t.id,
    t.acct,
    t.category,
    t.amount,
    t.description,
    t.notes,
    t.date,
    t.sort_order,
    t.cleared,
    t.pending,
    t.reconciled,
    t.isParent,
    t.isChild,
    t.parent_id,
    COALESCE(transfer_acct.name, p.name) AS payee_name,
    c.name AS category_name
FROM transactions t
LEFT JOIN payees p ON t.description = p.id
LEFT JOIN accounts transfer_acct ON p.transfer_acct = transfer_acct.id
LEFT JOIN categories c ON t.category = c.id
WHERE t.acct = ? AND t.tombstone = 0 AND t.isParent = 0
ORDER BY t.date DESC, t.sort_order DESC
LIMIT ? OFFSET ?;

-- Search transactions with text matching (server-side search)
-- Note: isParent = 0 filters out parent transactions to avoid double-counting splits
-- For transfer payees (transfer_acct set), resolves to account name instead of empty payee name
searchTransactionsForAccount:
SELECT
    t.id,
    t.acct,
    t.category,
    t.amount,
    t.description,
    t.notes,
    t.date,
    t.sort_order,
    t.cleared,
    t.pending,
    t.reconciled,
    t.isParent,
    t.isChild,
    t.parent_id,
    COALESCE(transfer_acct.name, p.name) AS payee_name,
    c.name AS category_name
FROM transactions t
LEFT JOIN payees p ON t.description = p.id
LEFT JOIN accounts transfer_acct ON p.transfer_acct = transfer_acct.id
LEFT JOIN categories c ON t.category = c.id
WHERE t.acct = ? AND t.tombstone = 0 AND t.isParent = 0
  AND (p.name LIKE ? OR t.notes LIKE ? OR CAST(t.amount AS TEXT) LIKE ?)
ORDER BY t.date DESC, t.sort_order DESC;

getTransactionsByDateRange:
SELECT * FROM transactions WHERE date >= ? AND date <= ? AND tombstone = 0 AND isParent = 0 ORDER BY date DESC, sort_order DESC;

getTransactionById:
SELECT * FROM transactions WHERE id = ?;

insertTransaction:
INSERT OR REPLACE INTO transactions(id, acct, category, amount, description, notes, date, sort_order, tombstone, cleared, pending, reconciled, isParent, isChild, parent_id, transferred_id)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);

-- Budget
getBudgetForMonth:
SELECT * FROM zero_budgets WHERE month = ? AND tombstone = 0;

getBudgetForCategory:
SELECT * FROM zero_budgets WHERE category = ? AND tombstone = 0;

getBudgetById:
SELECT * FROM zero_budgets WHERE id = ?;

insertBudget:
INSERT OR REPLACE INTO zero_budgets(id, month, category, amount, carryover, goal, tombstone)
VALUES (?, ?, ?, ?, ?, ?, ?);

-- CRDT Messages (using Actual Budget's column names: row, column, value as BLOB)
insertMessage:
INSERT OR IGNORE INTO messages_crdt(timestamp, dataset, row, column, value)
VALUES (?, ?, ?, ?, ?);

getMessagesSince:
SELECT * FROM messages_crdt WHERE timestamp > ? ORDER BY timestamp;

messageExists:
SELECT COUNT(*) AS cnt FROM messages_crdt WHERE timestamp = ?;

getLastTimestamp:
SELECT MAX(timestamp) AS last_ts FROM messages_crdt;

-- Sync Metadata
getSyncMetadata:
SELECT value FROM sync_metadata WHERE key = ?;

setSyncMetadata:
INSERT OR REPLACE INTO sync_metadata(key, value) VALUES (?, ?);

-- Generic row operations for CRDT apply
updateAccountColumn:
UPDATE accounts SET name = CASE WHEN ?1 = 'name' THEN ?3 ELSE name END,
                    offbudget = CASE WHEN ?1 = 'offbudget' THEN ?3 ELSE offbudget END,
                    closed = CASE WHEN ?1 = 'closed' THEN ?3 ELSE closed END,
                    sort_order = CASE WHEN ?1 = 'sort_order' THEN ?3 ELSE sort_order END,
                    tombstone = CASE WHEN ?1 = 'tombstone' THEN ?3 ELSE tombstone END
WHERE id = ?2;

updatePayeeColumn:
UPDATE payees SET name = CASE WHEN ?1 = 'name' THEN ?3 ELSE name END,
                  category = CASE WHEN ?1 = 'category' THEN ?3 ELSE category END,
                  tombstone = CASE WHEN ?1 = 'tombstone' THEN ?3 ELSE tombstone END,
                  transfer_acct = CASE WHEN ?1 = 'transfer_acct' THEN ?3 ELSE transfer_acct END
WHERE id = ?2;

updateCategoryColumn:
UPDATE categories SET name = CASE WHEN ?1 = 'name' THEN ?3 ELSE name END,
                      cat_group = CASE WHEN ?1 = 'cat_group' THEN ?3 ELSE cat_group END,
                      is_income = CASE WHEN ?1 = 'is_income' THEN ?3 ELSE is_income END,
                      sort_order = CASE WHEN ?1 = 'sort_order' THEN ?3 ELSE sort_order END,
                      hidden = CASE WHEN ?1 = 'hidden' THEN ?3 ELSE hidden END,
                      tombstone = CASE WHEN ?1 = 'tombstone' THEN ?3 ELSE tombstone END
WHERE id = ?2;

updateCategoryGroupColumn:
UPDATE category_groups SET name = CASE WHEN ?1 = 'name' THEN ?3 ELSE name END,
                           is_income = CASE WHEN ?1 = 'is_income' THEN ?3 ELSE is_income END,
                           sort_order = CASE WHEN ?1 = 'sort_order' THEN ?3 ELSE sort_order END,
                           hidden = CASE WHEN ?1 = 'hidden' THEN ?3 ELSE hidden END,
                           tombstone = CASE WHEN ?1 = 'tombstone' THEN ?3 ELSE tombstone END
WHERE id = ?2;

updateTransactionColumn:
UPDATE transactions SET acct = CASE WHEN ?1 = 'acct' THEN ?3 ELSE acct END,
                        category = CASE WHEN ?1 = 'category' THEN ?3 ELSE category END,
                        amount = CASE WHEN ?1 = 'amount' THEN ?3 ELSE amount END,
                        description = CASE WHEN ?1 = 'description' OR ?1 = 'payee' THEN ?3 ELSE description END,
                        notes = CASE WHEN ?1 = 'notes' THEN ?3 ELSE notes END,
                        date = CASE WHEN ?1 = 'date' THEN ?3 ELSE date END,
                        cleared = CASE WHEN ?1 = 'cleared' THEN ?3 ELSE cleared END,
                        pending = CASE WHEN ?1 = 'pending' THEN ?3 ELSE pending END,
                        reconciled = CASE WHEN ?1 = 'reconciled' THEN ?3 ELSE reconciled END,
                        tombstone = CASE WHEN ?1 = 'tombstone' THEN ?3 ELSE tombstone END,
                        sort_order = CASE WHEN ?1 = 'sort_order' THEN ?3 ELSE sort_order END,
                        isParent = CASE WHEN ?1 = 'isParent' OR ?1 = 'is_parent' THEN ?3 ELSE isParent END,
                        isChild = CASE WHEN ?1 = 'isChild' OR ?1 = 'is_child' THEN ?3 ELSE isChild END,
                        parent_id = CASE WHEN ?1 = 'parent_id' THEN ?3 ELSE parent_id END,
                        transferred_id = CASE WHEN ?1 = 'transferred_id' THEN ?3 ELSE transferred_id END
WHERE id = ?2;

-- Clear all data (for reset)
clearAccounts:
DELETE FROM accounts;

clearPayees:
DELETE FROM payees;

clearCategories:
DELETE FROM categories;

clearCategoryGroups:
DELETE FROM category_groups;

clearTransactions:
DELETE FROM transactions;

clearBudgets:
DELETE FROM zero_budgets;

clearMessages:
DELETE FROM messages_crdt;

clearMetadata:
DELETE FROM sync_metadata;

clearBudgetMonths:
DELETE FROM zero_budget_months;

-- Diagnostic queries (counts ALL rows, ignoring tombstone)
countAllAccounts:
SELECT COUNT(*) AS cnt FROM accounts;

countAllPayees:
SELECT COUNT(*) AS cnt FROM payees;

countAllCategories:
SELECT COUNT(*) AS cnt FROM categories;

countAllCategoryGroups:
SELECT COUNT(*) AS cnt FROM category_groups;

countAllTransactions:
SELECT COUNT(*) AS cnt FROM transactions;

-- Get ALL accounts (including tombstoned)
getAllAccounts:
SELECT * FROM accounts;

-- Get ALL payees (including tombstoned)
getAllPayees:
SELECT * FROM payees;

-- Get ALL categories (including tombstoned)
getAllCategories:
SELECT * FROM categories;

-- Get ALL category groups (including tombstoned)
getAllCategoryGroups:
SELECT * FROM category_groups;

-- Get ALL transactions (including tombstoned)
getAllTransactions:
SELECT * FROM transactions;

-- ============= OPTIMIZED QUERIES =============

-- Spending aggregation by category for a date range (on-budget accounts only)
-- Returns categoryId -> total spent (negative for expenses)
-- Note: isParent = 0 excludes parent transactions to avoid double-counting splits
getSpentByCategory:
SELECT category, SUM(amount) AS spent
FROM transactions
WHERE date >= ? AND date <= ?
  AND acct IN (SELECT id FROM accounts WHERE offbudget = 0 AND tombstone = 0)
  AND tombstone = 0
  AND isParent = 0
  AND category IS NOT NULL
GROUP BY category;

-- Categories with their group info pre-joined (for budget views)
-- Returns categories ordered by group then category sort order
getCategoriesWithGroups:
SELECT c.id, c.name, c.cat_group, c.sort_order AS cat_sort, c.is_income, c.hidden AS cat_hidden,
       g.id AS group_id, g.name AS group_name, g.sort_order AS group_sort, g.hidden AS group_hidden
FROM categories c
INNER JOIN category_groups g ON c.cat_group = g.id
WHERE c.tombstone = 0 AND c.hidden = 0
  AND g.tombstone = 0 AND g.hidden = 0
ORDER BY g.sort_order, c.sort_order;

-- Get account balance (sum of all transaction amounts for an account)
-- Note: isParent = 0 excludes parent transactions to avoid double-counting splits
getAccountBalance:
SELECT COALESCE(SUM(amount), 0) AS balance
FROM transactions
WHERE acct = ? AND tombstone = 0 AND isParent = 0;

-- ============= RECONCILIATION QUERIES =============

-- Get cleared balance for an account (only cleared transactions, for reconciliation)
-- Note: isParent = 0 excludes parent transactions to avoid double-counting splits
getClearedBalance:
SELECT COALESCE(SUM(amount), 0) AS balance
FROM transactions
WHERE acct = ? AND tombstone = 0 AND cleared = 1 AND isParent = 0;

-- Get uncleared transactions for an account (for reconciliation view)
getUnclearedTransactions:
SELECT * FROM transactions
WHERE acct = ? AND tombstone = 0 AND cleared = 0 AND isParent = 0
ORDER BY date DESC, sort_order DESC;

-- Get uncleared transaction count for an account
getUnclearedCount:
SELECT COUNT(*) AS cnt FROM transactions
WHERE acct = ? AND tombstone = 0 AND cleared = 0 AND isParent = 0;

-- Get reconciled transactions for an account (locked after reconciliation)
getReconciledTransactions:
SELECT * FROM transactions
WHERE acct = ? AND tombstone = 0 AND reconciled = 1 AND isParent = 0
ORDER BY date DESC, sort_order DESC;

-- Get transactions pending bank confirmation
getPendingTransactions:
SELECT * FROM transactions
WHERE acct = ? AND tombstone = 0 AND pending = 1 AND isParent = 0
ORDER BY date DESC, sort_order DESC;

-- Get reconciliation summary for an account
-- Returns: total balance, cleared balance, uncleared balance, uncleared count
-- Note: isParent = 0 excludes parent transactions to avoid double-counting splits
getReconciliationSummary:
SELECT
    COALESCE(SUM(amount), 0) AS total_balance,
    COALESCE(SUM(CASE WHEN cleared = 1 THEN amount ELSE 0 END), 0) AS cleared_balance,
    COALESCE(SUM(CASE WHEN cleared = 0 THEN amount ELSE 0 END), 0) AS uncleared_balance,
    SUM(CASE WHEN cleared = 0 THEN 1 ELSE 0 END) AS uncleared_count
FROM transactions
WHERE acct = ? AND tombstone = 0 AND isParent = 0;

-- Get cleared but not yet reconciled transactions (for reconciliation)
-- These are transactions ready to be locked during reconciliation
getClearedUnreconciledTransactions:
SELECT * FROM transactions
WHERE acct = ? AND tombstone = 0 AND cleared = 1 AND reconciled = 0 AND isParent = 0
ORDER BY date DESC, sort_order DESC;

-- Get count of cleared but not yet reconciled transactions
getClearedUnreconciledCount:
SELECT COUNT(*) AS cnt FROM transactions
WHERE acct = ? AND tombstone = 0 AND cleared = 1 AND reconciled = 0 AND isParent = 0;

-- ============= SPLIT TRANSACTION QUERIES =============

-- Get child transactions for a parent (split) transaction
getChildTransactions:
SELECT * FROM transactions
WHERE parent_id = ? AND tombstone = 0
ORDER BY sort_order DESC;

-- Get child transactions with details for a parent
-- For transfer payees (transfer_acct set), resolves to account name instead of empty payee name
getChildTransactionsWithDetails:
SELECT
    t.id,
    t.acct,
    t.category,
    t.amount,
    t.description,
    t.notes,
    t.date,
    t.sort_order,
    t.cleared,
    t.pending,
    t.reconciled,
    t.isParent,
    t.isChild,
    t.parent_id,
    COALESCE(transfer_acct.name, p.name) AS payee_name,
    c.name AS category_name
FROM transactions t
LEFT JOIN payees p ON t.description = p.id
LEFT JOIN accounts transfer_acct ON p.transfer_acct = transfer_acct.id
LEFT JOIN categories c ON t.category = c.id
WHERE t.parent_id = ? AND t.tombstone = 0
ORDER BY t.sort_order DESC;

-- Check if a transaction is a parent (has children)
hasChildTransactions:
SELECT COUNT(*) AS cnt FROM transactions
WHERE parent_id = ? AND tombstone = 0;

-- ============= TRANSFER QUERIES =============

-- Get transfer payee for a specific account
-- Transfer payees have transfer_acct pointing to the account they represent
getTransferPayeeForAccount:
SELECT * FROM payees WHERE transfer_acct = ? AND tombstone = 0;

-- Get all transfer payees (payees with transfer_acct set)
getPayeesWithTransferAcct:
SELECT * FROM payees WHERE transfer_acct IS NOT NULL AND tombstone = 0;

-- Check if a transaction is a transfer (has transferred_id set)
isTransferTransaction:
SELECT CASE WHEN transferred_id IS NOT NULL THEN 1 ELSE 0 END AS is_transfer
FROM transactions WHERE id = ?;

-- Get the linked (paired) transaction for a transfer
getLinkedTransaction:
SELECT * FROM transactions WHERE id = (
    SELECT transferred_id FROM transactions WHERE id = ?
);

-- Get transaction with its transferred_id
getTransactionWithTransfer:
SELECT * FROM transactions WHERE id = ?;

-- ============= BUDGET MONTH QUERIES =============

-- Insert or update budget month (for hold operations)
insertBudgetMonth:
INSERT OR REPLACE INTO zero_budget_months(id, buffered) VALUES (?, ?);

-- Get budget month by ID
getBudgetMonth:
SELECT * FROM zero_budget_months WHERE id = ?;

-- Get sum of spending by category for N previous months (for average calculation)
-- Returns categoryId -> total spent (negative for expenses) and month count
getSpentByCategoryForMonths:
SELECT category, SUM(amount) AS total_spent, COUNT(DISTINCT (date / 100)) AS month_count
FROM transactions
WHERE date >= ? AND date < ?
  AND acct IN (SELECT id FROM accounts WHERE offbudget = 0 AND tombstone = 0)
  AND tombstone = 0
  AND isParent = 0
  AND category IS NOT NULL
GROUP BY category;

-- Get total income for a month (for calculating "to budget")
-- Income is transactions in income categories (positive amounts)
getTotalIncomeForMonth:
SELECT COALESCE(SUM(t.amount), 0) AS total_income
FROM transactions t
INNER JOIN categories c ON t.category = c.id
WHERE (t.date / 100) = ?
  AND c.is_income = 1
  AND t.tombstone = 0
  AND t.isParent = 0
  AND t.acct IN (SELECT id FROM accounts WHERE offbudget = 0 AND tombstone = 0);

-- Get total budgeted for a month
getTotalBudgetedForMonth:
SELECT COALESCE(SUM(amount), 0) AS total_budgeted
FROM zero_budgets
WHERE month = ? AND tombstone = 0;

-- ============= REORDERING QUERIES =============

-- Get categories in a group ordered by sort_order
getCategoriesInGroupOrdered:
SELECT * FROM categories WHERE cat_group = ? AND tombstone = 0 ORDER BY sort_order;

-- Get all category groups ordered by sort_order
getCategoryGroupsOrdered:
SELECT * FROM category_groups WHERE tombstone = 0 ORDER BY sort_order;

-- Get on-budget accounts ordered by sort_order
getOnBudgetAccountsOrdered:
SELECT * FROM accounts WHERE offbudget = 0 AND closed = 0 AND tombstone = 0 ORDER BY sort_order;

-- Get off-budget accounts ordered by sort_order
getOffBudgetAccountsOrdered:
SELECT * FROM accounts WHERE offbudget = 1 AND closed = 0 AND tombstone = 0 ORDER BY sort_order;

-- Get closed accounts ordered by sort_order
getClosedAccountsOrdered:
SELECT * FROM accounts WHERE closed = 1 AND tombstone = 0 ORDER BY sort_order;
